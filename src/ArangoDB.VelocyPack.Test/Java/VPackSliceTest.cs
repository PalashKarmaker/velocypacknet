using ArangoDB.VelocyPack;
using ArangoDB.VelocyPack.Exceptions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Xunit;

namespace ArangoDB.VelocyPack.Test.Java
{
    public class SliceTest
    {
        [Fact]
        public void IsNone()
        {
            byte[] vpack = { 0x00 };
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.None));
        }

        [Fact]
        public void IsNull()
        {
            byte[] vpack = { 0x18 };
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.Null));
        }

        [Fact]
        public void IsIllegal()
        {
            byte[] vpack = { 0x17 };
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.Illegal));
        }

        [Fact]
        public void BooleanTrue()
        {
            byte[] vpack = { 0x1a };
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.Boolean));
            Assert.True(slice.ToBoolean());
            Assert.False(slice.ToBoolean()==false);
            Assert.Equal(slice.GetByteSize(), 1);
        }

        [Fact]
        public void BooleanFalse()
        {
            byte[] vpack = { 0x19 };
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.Boolean));
            Assert.True(slice.ToBoolean() == false);
            Assert.False(slice.ToBoolean());
            Assert.Equal(slice.GetByteSize(), 1);
        }

        [Fact]
        public void IsArray()
        {
            CheckArray(new byte[] { 0x01 });
            CheckArray(new byte[] { 0x02 });
            CheckArray(new byte[] { 0x03 });
            CheckArray(new byte[] { 0x04 });
            CheckArray(new byte[] { 0x05 });
            CheckArray(new byte[] { 0x06 });
            CheckArray(new byte[] { 0x07 });
            CheckArray(new byte[] { 0x08 });
            CheckArray(new byte[] { 0x09 });
            CheckArray(new byte[] { 0x13 });
        }

        void CheckArray(byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.Array));
        }

        [Fact]
        public void IsObject()
        {
            CheckObject(new byte[] { 0x0b });
            CheckObject(new byte[] { 0x0c });
            CheckObject(new byte[] { 0x0d });
            CheckObject(new byte[] { 0x0e });
            CheckObject(new byte[] { 0x0f });
            CheckObject(new byte[] { 0x10 });
            CheckObject(new byte[] { 0x11 });
            CheckObject(new byte[] { 0x12 });
            CheckObject(new byte[] { 0x14 });
        }

        void CheckObject(byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.Object));
        }

        [Fact]
        public void IsDouble()
        {
            byte[] vpack = { 0x1b };
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.Double));
            Assert.True(slice.IsNumeric());
        }

        [Fact]
        public void IsUTCDate()
        {
            byte[] vpack = { 0x1c };
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.UtcDate));
        }

        [Fact]
        public void IsExternal()
        {
            byte[] vpack = { 0x1d };
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.External));
        }

        [Fact]
        public void IsMinKey()
        {
            byte[] vpack = { 0x1e };
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.MinKey));
        }

        [Fact]
        public void IsMaxKey()
        {
            byte[] vpack = { 0x1f };
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.MaxKey));
        }

        [Fact]
        public void IsInt()
        {
            CheckInt(new byte[] { 0x20 });
            CheckInt(new byte[] { 0x21 });
            CheckInt(new byte[] { 0x22 });
            CheckInt(new byte[] { 0x23 });
            CheckInt(new byte[] { 0x24 });
            CheckInt(new byte[] { 0x25 });
            CheckInt(new byte[] { 0x26 });
            CheckInt(new byte[] { 0x27 });
        }

        void CheckInt(byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.Int));
            Assert.True(slice.IsInteger());
            Assert.True(slice.IsNumeric());
        }

        [Fact]
        public void IsUInt()
        {
            CheckUInt(new byte[] { 0x28 });
            CheckUInt(new byte[] { 0x29 });
            CheckUInt(new byte[] { 0x2a });
            CheckUInt(new byte[] { 0x2b });
            CheckUInt(new byte[] { 0x2c });
            CheckUInt(new byte[] { 0x2d });
            CheckUInt(new byte[] { 0x2e });
            CheckUInt(new byte[] { 0x2f });
        }

        void CheckUInt(byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.UInt));
            Assert.True(slice.IsInteger());
            Assert.True(slice.IsNumeric());
        }

        [Fact]
        public void IsSmallInt()
        {
            CheckSmallInt(new byte[] { 0x30 });
            CheckSmallInt(new byte[] { 0x31 });
            CheckSmallInt(new byte[] { 0x32 });
            CheckSmallInt(new byte[] { 0x33 });
            CheckSmallInt(new byte[] { 0x34 });
            CheckSmallInt(new byte[] { 0x35 });
            CheckSmallInt(new byte[] { 0x36 });
            CheckSmallInt(new byte[] { 0x37 });
            CheckSmallInt(new byte[] { 0x38 });
            CheckSmallInt(new byte[] { 0x39 });
            CheckSmallInt(new byte[] { 0x3a });
            CheckSmallInt(new byte[] { 0x3b });
            CheckSmallInt(new byte[] { 0x3c });
            CheckSmallInt(new byte[] { 0x3d });
            CheckSmallInt(new byte[] { 0x3e });
            CheckSmallInt(new byte[] { 0x3f });
        }

        void CheckSmallInt(byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.SmallInt));
            Assert.True(slice.IsInteger());
            Assert.True(slice.IsNumeric());
        }

        [Fact]
        public void IsString()
        {
            CheckString(new byte[] { 0x40 });
            CheckString(new byte[] { 0x41 });
            CheckString(new byte[] { 0x42 });
            CheckString(new byte[] { 0x43 });
            CheckString(new byte[] { 0x44 });
            CheckString(new byte[] { 0x45 });
            CheckString(new byte[] { 0x46 });
            CheckString(new byte[] { 0x47 });
            CheckString(new byte[] { 0x48 });
            CheckString(new byte[] { 0x49 });
            CheckString(new byte[] { 0x4a });
            CheckString(new byte[] { 0x4b });
            CheckString(new byte[] { 0x4c });
            CheckString(new byte[] { 0x4d });
            CheckString(new byte[] { 0x4e });
            CheckString(new byte[] { 0x4f });
            CheckString(new byte[] { 0x50 });
            CheckString(new byte[] { 0x51 });
            CheckString(new byte[] { 0x52 });
            CheckString(new byte[] { 0x53 });
            CheckString(new byte[] { 0x54 });
            CheckString(new byte[] { 0x55 });
            CheckString(new byte[] { 0x56 });
            CheckString(new byte[] { 0x57 });
            CheckString(new byte[] { 0x58 });
            CheckString(new byte[] { 0x59 });
            CheckString(new byte[] { 0x5a });
            CheckString(new byte[] { 0x5b });
            CheckString(new byte[] { 0x5c });
            CheckString(new byte[] { 0x5d });
            CheckString(new byte[] { 0x5e });
            CheckString(new byte[] { 0x5f });
            CheckString(new byte[] { 0x60 });
            CheckString(new byte[] { 0x61 });
            CheckString(new byte[] { 0x62 });
            CheckString(new byte[] { 0x63 });
            CheckString(new byte[] { 0x64 });
            CheckString(new byte[] { 0x65 });
            CheckString(new byte[] { 0x66 });
            CheckString(new byte[] { 0x67 });
            CheckString(new byte[] { 0x68 });
            CheckString(new byte[] { 0x69 });
            CheckString(new byte[] { 0x6a });
            CheckString(new byte[] { 0x6b });
            CheckString(new byte[] { 0x6c });
            CheckString(new byte[] { 0x6d });
            CheckString(new byte[] { 0x6e });
            CheckString(new byte[] { 0x6f });
            CheckString(new byte[] { 0x70 });
            CheckString(new byte[] { 0x71 });
            CheckString(new byte[] { 0x72 });
            CheckString(new byte[] { 0x73 });
            CheckString(new byte[] { 0x74 });
            CheckString(new byte[] { 0x75 });
            CheckString(new byte[] { 0x76 });
            CheckString(new byte[] { 0x77 });
            CheckString(new byte[] { 0x78 });
            CheckString(new byte[] { 0x79 });
            CheckString(new byte[] { 0x7a });
            CheckString(new byte[] { 0x7b });
            CheckString(new byte[] { 0x7c });
            CheckString(new byte[] { 0x7d });
            CheckString(new byte[] { 0x7e });
            CheckString(new byte[] { 0x7f });
            CheckString(new byte[] { 0x80 });
            CheckString(new byte[] { 0x81 });
            CheckString(new byte[] { 0x82 });
            CheckString(new byte[] { 0x83 });
            CheckString(new byte[] { 0x84 });
            CheckString(new byte[] { 0x85 });
            CheckString(new byte[] { 0x86 });
            CheckString(new byte[] { 0x87 });
            CheckString(new byte[] { 0x88 });
            CheckString(new byte[] { 0x89 });
            CheckString(new byte[] { 0x8a });
            CheckString(new byte[] { 0x8b });
            CheckString(new byte[] { 0x8c });
            CheckString(new byte[] { 0x8d });
            CheckString(new byte[] { 0x8e });
            CheckString(new byte[] { 0x8f });
            CheckString(new byte[] { 0x90 });
            CheckString(new byte[] { 0x91 });
            CheckString(new byte[] { 0x92 });
            CheckString(new byte[] { 0x93 });
            CheckString(new byte[] { 0x94 });
            CheckString(new byte[] { 0x95 });
            CheckString(new byte[] { 0x96 });
            CheckString(new byte[] { 0x97 });
            CheckString(new byte[] { 0x98 });
            CheckString(new byte[] { 0x99 });
            CheckString(new byte[] { 0x9a });
            CheckString(new byte[] { 0x9b });
            CheckString(new byte[] { 0x9c });
            CheckString(new byte[] { 0x9d });
            CheckString(new byte[] { 0x9e });
            CheckString(new byte[] { 0x9f });
            CheckString(new byte[] { 0xa0 });
            CheckString(new byte[] { 0xa1 });
            CheckString(new byte[] { 0xa2 });
            CheckString(new byte[] { 0xa3 });
            CheckString(new byte[] { 0xa4 });
            CheckString(new byte[] { 0xa5 });
            CheckString(new byte[] { 0xa6 });
            CheckString(new byte[] { 0xa7 });
            CheckString(new byte[] { 0xa8 });
            CheckString(new byte[] { 0xa9 });
            CheckString(new byte[] { 0xaa });
            CheckString(new byte[] { 0xab });
            CheckString(new byte[] { 0xac });
            CheckString(new byte[] { 0xad });
            CheckString(new byte[] { 0xae });
            CheckString(new byte[] { 0xaf });
            CheckString(new byte[] { 0xb0 });
            CheckString(new byte[] { 0xb1 });
            CheckString(new byte[] { 0xb2 });
            CheckString(new byte[] { 0xb3 });
            CheckString(new byte[] { 0xb4 });
            CheckString(new byte[] { 0xb5 });
            CheckString(new byte[] { 0xb6 });
            CheckString(new byte[] { 0xb7 });
            CheckString(new byte[] { 0xb8 });
            CheckString(new byte[] { 0xb9 });
            CheckString(new byte[] { 0xba });
            CheckString(new byte[] { 0xbb });
            CheckString(new byte[] { 0xbc });
            CheckString(new byte[] { 0xbd });
            CheckString(new byte[] { 0xbe });
            CheckString(new byte[] { 0xbf });
        }

        void CheckString(byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.String));
        }

        [Fact]
        public void IsBinary()
        {
            CheckBinary(new byte[] { (byte)0xc0 });
            CheckBinary(new byte[] { (byte)0xc1 });
            CheckBinary(new byte[] { (byte)0xc2 });
            CheckBinary(new byte[] { (byte)0xc3 });
            CheckBinary(new byte[] { (byte)0xc4 });
            CheckBinary(new byte[] { (byte)0xc5 });
            CheckBinary(new byte[] { (byte)0xc6 });
            CheckBinary(new byte[] { (byte)0xc7 });
        }

        void CheckBinary(byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.Binary));
        }

        [Fact]
        public void IsBCD()
        {
            CheckBCD(new byte[] { (byte)0xc8 });
            CheckBCD(new byte[] { (byte)0xc9 });
            CheckBCD(new byte[] { (byte)0xca });
            CheckBCD(new byte[] { (byte)0xcb });
            CheckBCD(new byte[] { (byte)0xcc });
            CheckBCD(new byte[] { (byte)0xcd });
            CheckBCD(new byte[] { (byte)0xce });
            CheckBCD(new byte[] { (byte)0xcf });
            CheckBCD(new byte[] { (byte)0xd0 });
            CheckBCD(new byte[] { (byte)0xd1 });
            CheckBCD(new byte[] { (byte)0xd2 });
            CheckBCD(new byte[] { (byte)0xd3 });
            CheckBCD(new byte[] { (byte)0xd4 });
            CheckBCD(new byte[] { (byte)0xd5 });
            CheckBCD(new byte[] { (byte)0xd6 });
            CheckBCD(new byte[] { (byte)0xd7 });
        }

        void CheckBCD(byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.Bcd));
        }

        [Fact]
        public void IsCustom()
        {
            CheckCustom(new byte[] { (byte)0xf0 });
            CheckCustom(new byte[] { (byte)0xf1 });
            CheckCustom(new byte[] { (byte)0xf2 });
            CheckCustom(new byte[] { (byte)0xf3 });
            CheckCustom(new byte[] { (byte)0xf4 });
            CheckCustom(new byte[] { (byte)0xf5 });
            CheckCustom(new byte[] { (byte)0xf6 });
            CheckCustom(new byte[] { (byte)0xf7 });
            CheckCustom(new byte[] { (byte)0xf8 });
            CheckCustom(new byte[] { (byte)0xf9 });
            CheckCustom(new byte[] { (byte)0xfa });
            CheckCustom(new byte[] { (byte)0xfb });
            CheckCustom(new byte[] { (byte)0xfc });
            CheckCustom(new byte[] { (byte)0xfd });
            CheckCustom(new byte[] { (byte)0xfe });
            CheckCustom(new byte[] { (byte)0xff });
        }

        void CheckCustom(byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);
            Assert.True(slice.IsType(SliceType.Custom));
        }

        [Fact]
        public void GetBooleanTrue()
        {
            byte[] vpack = { 0x1a };
            VPackSlice slice = new VPackSlice(vpack);

            Assert.True(slice.ToBoolean());
        }

        [Fact]
        public void GetBooleanFalse()
        {
            byte[] vpack = { 0x19 };
            VPackSlice slice = new VPackSlice(vpack);

            Assert.False(slice.ToBoolean());
        }

        [Fact]
        public void GetBooleanFail()
        {
            VPackSlice slice = new VPackSlice(new byte[] { 0x00 });
            Assert.Throws<InvalidOperationException>(() => slice.ToBoolean());
        }

        [Fact]
        public void GetDouble()
        {
            {
                byte[] vpack = { 0x1b, 0x66, 0x66, 0x66, 0x66, 0x66, (byte)0xb6, 0x60, 0x40 };
                VPackSlice slice = new VPackSlice(vpack);
                Assert.Equal(slice.ToDouble(), 133.7);
            }

            {
                byte[] vpack = { 0x1b, 0x66, 0x66, 0x66, 0x66, 0x66, (byte)0xb6, 0x60, (byte)0xc0 };
                VPackSlice slice = new VPackSlice(vpack);
                Assert.Equal(slice.ToDouble(), -133.7);
            }
        }

        [Fact]
        public void GetDoubleAsNumber()
        {
            {
                byte[] vpack = { 0x1b, 0x66, 0x66, 0x66, 0x66, 0x66, (byte)0xb6, 0x60, 0x40 };
                VPackSlice slice = new VPackSlice(vpack);
                Assert.Equal(slice.Value(), 133.7d);
            }

            {
                byte[] vpack = { 0x1b, 0x66, 0x66, 0x66, 0x66, 0x66, (byte)0xb6, 0x60, (byte)0xc0 };
                VPackSlice slice = new VPackSlice(vpack);
                Assert.Equal(slice.Value(), -133.7d);
            }
        }

        [Fact]
        public void GetDoubleFail()
        {
            VPackSlice slice = new VPackSlice(new byte[] { 0x00 });
            Assert.Throws<InvalidOperationException>(() => slice.ToDouble());
        }

        [Fact]
        public void GetSmallInt()
        {
            CheckSmallInt(0, new byte[] { 0x30 });

            CheckSmallInt(1, new byte[] { 0x31 });

            CheckSmallInt(2, new byte[] { 0x32 });

            CheckSmallInt(3, new byte[] { 0x33 });

            CheckSmallInt(4, new byte[] { 0x34 });

            CheckSmallInt(5, new byte[] { 0x35 });

            CheckSmallInt(6, new byte[] { 0x36 });

            CheckSmallInt(7, new byte[] { 0x37 });

            CheckSmallInt(8, new byte[] { 0x38 });

            CheckSmallInt(9, new byte[] { 0x39 });

            CheckSmallInt(-6, new byte[] { 0x3a });

            CheckSmallInt(-5, new byte[] { 0x3b });

            CheckSmallInt(-4, new byte[] { 0x3c });

            CheckSmallInt(-3, new byte[] { 0x3d });

            CheckSmallInt(-2, new byte[] { 0x3e });

            CheckSmallInt(-1, new byte[] { 0x3f });
        }

        void CheckSmallInt(int expecteds, byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);

            Assert.Equal(slice.ToInt32(), expecteds);
        }

        [Fact]
        public void GetInt()
        {
            CheckInt(short.MaxValue, new byte[] { 0x29, (byte)0xff, 0x7f });

            CheckInt(int.MaxValue, new byte[] { 0x2b, (byte)0xff, (byte)0xff, (byte)0xff, 0x7f });

            unchecked
            {
                CheckInt(long.MaxValue, new byte[] { 0x27, (byte)-1, (byte)-1, (byte)-1, (byte)-1, (byte)-1, (byte)-1, (byte)-1, 127 });
            }
        }

        void CheckInt(long expextedValue, byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);

            Assert.Equal(slice.ToInt64(), expextedValue);
        }

        [Fact]
        public void GetUInt()
        {
            unchecked
            {
                CheckUInt(short.MaxValue, new byte[] { 0x29, (byte)-1, 127 });

                CheckUInt(int.MaxValue, new byte[] { 0x2b, (byte)-1, (byte)-1, (byte)-1, 127 });

                CheckUInt(long.MaxValue, new byte[] { 0x2f, (byte)-1, (byte)-1, (byte)-1, (byte)-1, (byte)-1, (byte)-1, (byte)-1, 127 });
            }
        }

        void CheckUInt(long expecteds, byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);

            Assert.Equal(slice.ToInt64(), expecteds);
        }

        [Fact]
        public void GetString()
        {
            CheckString("Hallo Welt!", new byte[] { 0x4b, 72, 97, 108, 108, 111, 32, 87, 101, 108, 116, 33 });

            CheckString("Hello World!", new byte[] { 0x4c, 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33 });

            CheckString(
                "Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate eleifend tellus.",

                new byte[] { (byte) 0xbf, 0x37, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x6f, 0x72, 0x65, 0x6d,
                    0x20, 0x69, 0x70, 0x73, 0x75, 0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x73, 0x69, 0x74,
                    0x20, 0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x74, 0x65, 0x74,
                    0x75, 0x65, 0x72, 0x20, 0x61, 0x64, 0x69, 0x70, 0x69, 0x73, 0x63, 0x69, 0x6e, 0x67, 0x20, 0x65,
                    0x6c, 0x69, 0x74, 0x2e, 0x20, 0x41, 0x65, 0x6e, 0x65, 0x61, 0x6e, 0x20, 0x63, 0x6f, 0x6d, 0x6d,
                    0x6f, 0x64, 0x6f, 0x20, 0x6c, 0x69, 0x67, 0x75, 0x6c, 0x61, 0x20, 0x65, 0x67, 0x65, 0x74, 0x20,
                    0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x2e, 0x20, 0x41, 0x65, 0x6e, 0x65, 0x61, 0x6e, 0x20, 0x6d, 0x61,
                    0x73, 0x73, 0x61, 0x2e, 0x20, 0x43, 0x75, 0x6d, 0x20, 0x73, 0x6f, 0x63, 0x69, 0x69, 0x73, 0x20,
                    0x6e, 0x61, 0x74, 0x6f, 0x71, 0x75, 0x65, 0x20, 0x70, 0x65, 0x6e, 0x61, 0x74, 0x69, 0x62, 0x75,
                    0x73, 0x20, 0x65, 0x74, 0x20, 0x6d, 0x61, 0x67, 0x6e, 0x69, 0x73, 0x20, 0x64, 0x69, 0x73, 0x20,
                    0x70, 0x61, 0x72, 0x74, 0x75, 0x72, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x6f, 0x6e, 0x74, 0x65,
                    0x73, 0x2c, 0x20, 0x6e, 0x61, 0x73, 0x63, 0x65, 0x74, 0x75, 0x72, 0x20, 0x72, 0x69, 0x64, 0x69,
                    0x63, 0x75, 0x6c, 0x75, 0x73, 0x20, 0x6d, 0x75, 0x73, 0x2e, 0x20, 0x44, 0x6f, 0x6e, 0x65, 0x63,
                    0x20, 0x71, 0x75, 0x61, 0x6d, 0x20, 0x66, 0x65, 0x6c, 0x69, 0x73, 0x2c, 0x20, 0x75, 0x6c, 0x74,
                    0x72, 0x69, 0x63, 0x69, 0x65, 0x73, 0x20, 0x6e, 0x65, 0x63, 0x2c, 0x20, 0x70, 0x65, 0x6c, 0x6c,
                    0x65, 0x6e, 0x74, 0x65, 0x73, 0x71, 0x75, 0x65, 0x20, 0x65, 0x75, 0x2c, 0x20, 0x70, 0x72, 0x65,
                    0x74, 0x69, 0x75, 0x6d, 0x20, 0x71, 0x75, 0x69, 0x73, 0x2c, 0x20, 0x73, 0x65, 0x6d, 0x2e, 0x20,
                    0x4e, 0x75, 0x6c, 0x6c, 0x61, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x71, 0x75, 0x61, 0x74, 0x20,
                    0x6d, 0x61, 0x73, 0x73, 0x61, 0x20, 0x71, 0x75, 0x69, 0x73, 0x20, 0x65, 0x6e, 0x69, 0x6d, 0x2e,
                    0x20, 0x44, 0x6f, 0x6e, 0x65, 0x63, 0x20, 0x70, 0x65, 0x64, 0x65, 0x20, 0x6a, 0x75, 0x73, 0x74,
                    0x6f, 0x2c, 0x20, 0x66, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6c, 0x6c, 0x61, 0x20, 0x76, 0x65, 0x6c,
                    0x2c, 0x20, 0x61, 0x6c, 0x69, 0x71, 0x75, 0x65, 0x74, 0x20, 0x6e, 0x65, 0x63, 0x2c, 0x20, 0x76,
                    0x75, 0x6c, 0x70, 0x75, 0x74, 0x61, 0x74, 0x65, 0x20, 0x65, 0x67, 0x65, 0x74, 0x2c, 0x20, 0x61,
                    0x72, 0x63, 0x75, 0x2e, 0x20, 0x49, 0x6e, 0x20, 0x65, 0x6e, 0x69, 0x6d, 0x20, 0x6a, 0x75, 0x73,
                    0x74, 0x6f, 0x2c, 0x20, 0x72, 0x68, 0x6f, 0x6e, 0x63, 0x75, 0x73, 0x20, 0x75, 0x74, 0x2c, 0x20,
                    0x69, 0x6d, 0x70, 0x65, 0x72, 0x64, 0x69, 0x65, 0x74, 0x20, 0x61, 0x2c, 0x20, 0x76, 0x65, 0x6e,
                    0x65, 0x6e, 0x61, 0x74, 0x69, 0x73, 0x20, 0x76, 0x69, 0x74, 0x61, 0x65, 0x2c, 0x20, 0x6a, 0x75,
                    0x73, 0x74, 0x6f, 0x2e, 0x20, 0x4e, 0x75, 0x6c, 0x6c, 0x61, 0x6d, 0x20, 0x64, 0x69, 0x63, 0x74,
                    0x75, 0x6d, 0x20, 0x66, 0x65, 0x6c, 0x69, 0x73, 0x20, 0x65, 0x75, 0x20, 0x70, 0x65, 0x64, 0x65,
                    0x20, 0x6d, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x20, 0x70, 0x72, 0x65, 0x74, 0x69, 0x75, 0x6d, 0x2e,
                    0x20, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x74, 0x69, 0x6e, 0x63, 0x69, 0x64, 0x75,
                    0x6e, 0x74, 0x2e, 0x20, 0x43, 0x72, 0x61, 0x73, 0x20, 0x64, 0x61, 0x70, 0x69, 0x62, 0x75, 0x73,
                    0x2e, 0x20, 0x56, 0x69, 0x76, 0x61, 0x6d, 0x75, 0x73, 0x20, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e,
                    0x74, 0x75, 0x6d, 0x20, 0x73, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x20, 0x6e, 0x69, 0x73, 0x69, 0x2e,
                    0x20, 0x41, 0x65, 0x6e, 0x65, 0x61, 0x6e, 0x20, 0x76, 0x75, 0x6c, 0x70, 0x75, 0x74, 0x61, 0x74,
                    0x65, 0x20, 0x65, 0x6c, 0x65, 0x69, 0x66, 0x65, 0x6e, 0x64, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x75,
                    0x73, 0x2e });
        }

        void CheckString(string expecteds, byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);

            Assert.Equal(slice.ToStringValue(), expecteds);
        }

        [Fact]
        public void GetStringLength()
        {
            CheckStringLength(11, new byte[] { 0x4b, 72, 97, 108, 108, 111, 32, 87, 101, 108, 116, 33 });

            CheckStringLength(12, new byte[] { 0x4c, 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33 });

            CheckStringLength(567, new byte[] { (byte) 0xbf, 0x37, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x6f,
                0x72, 0x65, 0x6d, 0x20, 0x69, 0x70, 0x73, 0x75, 0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x73,
                0x69, 0x74, 0x20, 0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x74, 0x65,
                0x74, 0x75, 0x65, 0x72, 0x20, 0x61, 0x64, 0x69, 0x70, 0x69, 0x73, 0x63, 0x69, 0x6e, 0x67, 0x20, 0x65,
                0x6c, 0x69, 0x74, 0x2e, 0x20, 0x41, 0x65, 0x6e, 0x65, 0x61, 0x6e, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
                0x64, 0x6f, 0x20, 0x6c, 0x69, 0x67, 0x75, 0x6c, 0x61, 0x20, 0x65, 0x67, 0x65, 0x74, 0x20, 0x64, 0x6f,
                0x6c, 0x6f, 0x72, 0x2e, 0x20, 0x41, 0x65, 0x6e, 0x65, 0x61, 0x6e, 0x20, 0x6d, 0x61, 0x73, 0x73, 0x61,
                0x2e, 0x20, 0x43, 0x75, 0x6d, 0x20, 0x73, 0x6f, 0x63, 0x69, 0x69, 0x73, 0x20, 0x6e, 0x61, 0x74, 0x6f,
                0x71, 0x75, 0x65, 0x20, 0x70, 0x65, 0x6e, 0x61, 0x74, 0x69, 0x62, 0x75, 0x73, 0x20, 0x65, 0x74, 0x20,
                0x6d, 0x61, 0x67, 0x6e, 0x69, 0x73, 0x20, 0x64, 0x69, 0x73, 0x20, 0x70, 0x61, 0x72, 0x74, 0x75, 0x72,
                0x69, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x2c, 0x20, 0x6e, 0x61, 0x73, 0x63,
                0x65, 0x74, 0x75, 0x72, 0x20, 0x72, 0x69, 0x64, 0x69, 0x63, 0x75, 0x6c, 0x75, 0x73, 0x20, 0x6d, 0x75,
                0x73, 0x2e, 0x20, 0x44, 0x6f, 0x6e, 0x65, 0x63, 0x20, 0x71, 0x75, 0x61, 0x6d, 0x20, 0x66, 0x65, 0x6c,
                0x69, 0x73, 0x2c, 0x20, 0x75, 0x6c, 0x74, 0x72, 0x69, 0x63, 0x69, 0x65, 0x73, 0x20, 0x6e, 0x65, 0x63,
                0x2c, 0x20, 0x70, 0x65, 0x6c, 0x6c, 0x65, 0x6e, 0x74, 0x65, 0x73, 0x71, 0x75, 0x65, 0x20, 0x65, 0x75,
                0x2c, 0x20, 0x70, 0x72, 0x65, 0x74, 0x69, 0x75, 0x6d, 0x20, 0x71, 0x75, 0x69, 0x73, 0x2c, 0x20, 0x73,
                0x65, 0x6d, 0x2e, 0x20, 0x4e, 0x75, 0x6c, 0x6c, 0x61, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x71, 0x75,
                0x61, 0x74, 0x20, 0x6d, 0x61, 0x73, 0x73, 0x61, 0x20, 0x71, 0x75, 0x69, 0x73, 0x20, 0x65, 0x6e, 0x69,
                0x6d, 0x2e, 0x20, 0x44, 0x6f, 0x6e, 0x65, 0x63, 0x20, 0x70, 0x65, 0x64, 0x65, 0x20, 0x6a, 0x75, 0x73,
                0x74, 0x6f, 0x2c, 0x20, 0x66, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6c, 0x6c, 0x61, 0x20, 0x76, 0x65, 0x6c,
                0x2c, 0x20, 0x61, 0x6c, 0x69, 0x71, 0x75, 0x65, 0x74, 0x20, 0x6e, 0x65, 0x63, 0x2c, 0x20, 0x76, 0x75,
                0x6c, 0x70, 0x75, 0x74, 0x61, 0x74, 0x65, 0x20, 0x65, 0x67, 0x65, 0x74, 0x2c, 0x20, 0x61, 0x72, 0x63,
                0x75, 0x2e, 0x20, 0x49, 0x6e, 0x20, 0x65, 0x6e, 0x69, 0x6d, 0x20, 0x6a, 0x75, 0x73, 0x74, 0x6f, 0x2c,
                0x20, 0x72, 0x68, 0x6f, 0x6e, 0x63, 0x75, 0x73, 0x20, 0x75, 0x74, 0x2c, 0x20, 0x69, 0x6d, 0x70, 0x65,
                0x72, 0x64, 0x69, 0x65, 0x74, 0x20, 0x61, 0x2c, 0x20, 0x76, 0x65, 0x6e, 0x65, 0x6e, 0x61, 0x74, 0x69,
                0x73, 0x20, 0x76, 0x69, 0x74, 0x61, 0x65, 0x2c, 0x20, 0x6a, 0x75, 0x73, 0x74, 0x6f, 0x2e, 0x20, 0x4e,
                0x75, 0x6c, 0x6c, 0x61, 0x6d, 0x20, 0x64, 0x69, 0x63, 0x74, 0x75, 0x6d, 0x20, 0x66, 0x65, 0x6c, 0x69,
                0x73, 0x20, 0x65, 0x75, 0x20, 0x70, 0x65, 0x64, 0x65, 0x20, 0x6d, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x20,
                0x70, 0x72, 0x65, 0x74, 0x69, 0x75, 0x6d, 0x2e, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20,
                0x74, 0x69, 0x6e, 0x63, 0x69, 0x64, 0x75, 0x6e, 0x74, 0x2e, 0x20, 0x43, 0x72, 0x61, 0x73, 0x20, 0x64,
                0x61, 0x70, 0x69, 0x62, 0x75, 0x73, 0x2e, 0x20, 0x56, 0x69, 0x76, 0x61, 0x6d, 0x75, 0x73, 0x20, 0x65,
                0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x75, 0x6d, 0x20, 0x73, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x20, 0x6e,
                0x69, 0x73, 0x69, 0x2e, 0x20, 0x41, 0x65, 0x6e, 0x65, 0x61, 0x6e, 0x20, 0x76, 0x75, 0x6c, 0x70, 0x75,
                0x74, 0x61, 0x74, 0x65, 0x20, 0x65, 0x6c, 0x65, 0x69, 0x66, 0x65, 0x6e, 0x64, 0x20, 0x74, 0x65, 0x6c,
                0x6c, 0x75, 0x73, 0x2e });
        }

        void CheckStringLength(int expected, byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);

            Assert.Equal(slice.Length, expected);

            Assert.Equal(slice.GetByteSize(), vpack.Length);
        }

        [Fact]
        public void GetStringFail()
        {
            VPackSlice slice = new VPackSlice(new byte[] { 0x00 });
            Assert.Throws<InvalidOperationException>(() => slice.ToStringValue());
        }

        [Fact]
        public void GetBinary()
        {
            byte[] expected = new byte[] { 49, 50, 51, 52, 53, 54, 55, 56, 57 };

            CheckBinary(expected, new byte[] { (byte)0xc0, 9, 49, 50, 51, 52, 53, 54, 55, 56, 57 });

            CheckBinary(expected, new byte[] { (byte)0xc1, 9, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57 });

            CheckBinary(expected, new byte[] { (byte)0xc2, 9, 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57 });

            CheckBinary(expected, new byte[] { (byte)0xc3, 9, 0, 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57 });

            CheckBinary(expected, new byte[] { (byte)0xc4, 9, 0, 0, 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57 });

            CheckBinary(expected, new byte[] { (byte)0xc5, 9, 0, 0, 0, 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57 });

            CheckBinary(expected, new byte[] { (byte)0xc6, 9, 0, 0, 0, 0, 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57 });

            CheckBinary(expected, new byte[] { (byte)0xc7, 9, 0, 0, 0, 0, 0, 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57 });
        }

        void CheckBinary(byte[] expected, byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);

            Assert.Equal(slice.ToBinary(), expected);

            Assert.Equal(slice.GetByteSize(), vpack.Length);
        }

        [Fact]
        public void GetBinaryLength()
        {
            int expected = 9;

            CheckBinary(expected, new byte[] { (byte)0xc0, 9, 49, 50, 51, 52, 53, 54, 55, 56, 57 });

            CheckBinary(expected, new byte[] { (byte)0xc1, 9, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57 });

            CheckBinary(expected, new byte[] { (byte)0xc2, 9, 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57 });

            CheckBinary(expected, new byte[] { (byte)0xc3, 9, 0, 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57 });

            CheckBinary(expected, new byte[] { (byte)0xc4, 9, 0, 0, 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57 });

            CheckBinary(expected, new byte[] { (byte)0xc5, 9, 0, 0, 0, 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57 });

            CheckBinary(expected, new byte[] { (byte)0xc6, 9, 0, 0, 0, 0, 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57 });

            CheckBinary(expected, new byte[] { (byte)0xc7, 9, 0, 0, 0, 0, 0, 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57 });
        }

        void CheckBinary(int expected, byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);

            Assert.Equal(slice.BinaryLength(), expected);

            Assert.Equal(slice.GetByteSize(), vpack.Length);
        }

        [Fact]
        public void GetBinaryFail()
        {
            VPackSlice slice = new VPackSlice(new byte[] { 0x00 });
            Assert.Throws<VPackValueTypeException>(() => slice.ToBinary());
        }

        [Fact]
        public void GetBinaryLengthFail()
        {
            VPackSlice slice = new VPackSlice(new byte[] { 0x00 });
            Assert.Throws<VPackValueTypeException>(() => slice.BinaryLength());
        }

        [Fact]
        public void NotArrayAt()
        {
            VPackSlice slice = new VPackSlice(new byte[] { 0x1a });
            Assert.Throws<VPackValueTypeException>(() => slice[1]);
        }

        [Fact]
        public void ArrayEmpty()
        {
            CheckArray(new long[] { }, new byte[] { 0x01 });
        }

        [Fact]
        public void ArrayEmptyAt()
        {
            VPackSlice slice = new VPackSlice(new byte[] { 0x01 });
            Assert.Throws<IndexOutOfRangeException>(() => slice[1]);
        }

        [Fact]
        public void ArrayWrongIndex()
        {
            // [1, 2 ,3]
            VPackSlice slice = new VPackSlice(new byte[] { 0x02, 0x05, 0x31, 0x32, 0x33 });
            Assert.Throws<IndexOutOfRangeException>(() => slice[4]);
        }

        [Fact]
        public void ArrayWithoutIndexTable()
        {
            long[] expected = new long[] { 1, 2, 3 };

            CheckArray(expected, new byte[] { 0x02, 0x05, 0x31, 0x32, 0x33 });

            CheckArray(expected, new byte[] { 0x03, 0x06, 0x00, 0x31, 0x32, 0x33 });

            CheckArray(expected, new byte[] { 0x04, 0x08, 0x00, 0x00, 0x00, 0x31, 0x32, 0x33 });

            CheckArray(expected, new byte[] { 0x05, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x32, 0x33 });
        }

        [Fact]
        public void ArrayWithIndexTable()
        {
            long[] expected = new long[] { 1, 2, 3 };

            CheckArray(expected, new byte[] { 0x06, 0x09, 0x03, 0x31, 0x32, 0x33, 0x03, 0x04, 0x05 });

            CheckArray(expected,

                new byte[] { 0x07, 0x0e, 0x00, 0x03, 0x00, 0x31, 0x32, 0x33, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00 });

            CheckArray(expected, new byte[] { 0x08, 0x18, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x31, 0x32, 0x33, 0x09,
                0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00 });
        }

        [Fact]
        public void ArrayWithIndexTable8bytes()
        {
            long[] expected = new long[] { 1, 2, 3 };

            CheckArray(expected,

                new byte[] { 0x09, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x32, 0x33, 0x09, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });
        }

        [Fact]
        public void ArrayCompact()
        {
            long[] expected = { 1, 16 };

            CheckArray(expected, new byte[] { 0x13, 0x06, 0x31, 0x28, 0x10, 0x02 });
        }

        [Fact]
        public void ArrayCompactWrongIndex()
        {
            // [1, 16]
            VPackSlice slice = new VPackSlice(new byte[] { 0x13, 0x06, 0x31, 0x28, 0x10, 0x02 });
            Assert.Throws<IndexOutOfRangeException>(() => slice[3]);
        }

        [Fact]
        public void ArrayIncludesArray()
        {
            //{ { 1, 2, 3 }, { 1, 2, 3 } };
            long[][] expected = new long[2][];

            expected[0] = new long[] { 1, 2, 3 };
            expected[1] = new long[] { 1, 2, 3 };

            CheckArray(expected, new byte[] { 0x02, 0x0c, 0x02, 0x05, 0x31, 0x32, 0x33, 0x02, 0x05, 0x31, 0x32, 0x33 });
        }

        [Fact]
        public void ArrayIncludesArrayCompact()
        {
            long[][] expected = new long[2][];

            expected[0] = new long[] { 1, 2, 3 };
            expected[1] = new long[] { 1, 2, 3 };

            CheckArray(expected,

                new byte[] { 0x02, 0x0e, 0x13, 0x06, 0x31, 0x32, 0x33, 0x03, 0x13, 0x06, 0x31, 0x32, 0x33, 0x03 });
        }

        [Fact]
        public void ArrayIncludesObject()
        {
            // [{"a": 12, "b": true, "c": "xyz"},{"a": 12, "b": true, "c": "xyz"}]
            CheckLength(2,

            new byte[] { 0x13, 0x23, 0x14, 0x10, 0x41, 0x61, 0x28, 0x0c, 0x41, 0x62, 0x1a, 0x41, 0x63, 0x43, 0x78, 0x79,
                    0x7a, 0x03, 0x14, 0x10, 0x41, 0x61, 0x28, 0x0c, 0x41, 0x62, 0x1a, 0x41, 0x63, 0x43, 0x78, 0x79,
                    0x7a, 0x03, 0x02 });
        }

        [Fact]
        public void ArrayIncludesLongString()
        {
            CheckLength(1, new byte[] { 0x03, 0x49, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf, 0x37, 0x02, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x6f, 0x72, 0x65, 0x6d, 0x20, 0x69, 0x70, 0x73, 0x75, 0x6d, 0x20,
                0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x73, 0x69, 0x74, 0x20, 0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63,
                0x6f, 0x6e, 0x73, 0x65, 0x63, 0x74, 0x65, 0x74, 0x75, 0x65, 0x72, 0x20, 0x61, 0x64, 0x69, 0x70, 0x69,
                0x73, 0x63, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x6c, 0x69, 0x74, 0x2e, 0x20, 0x41, 0x65, 0x6e, 0x65, 0x61,
                0x6e, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x64, 0x6f, 0x20, 0x6c, 0x69, 0x67, 0x75, 0x6c, 0x61, 0x20,
                0x65, 0x67, 0x65, 0x74, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x2e, 0x20, 0x41, 0x65, 0x6e, 0x65, 0x61,
                0x6e, 0x20, 0x6d, 0x61, 0x73, 0x73, 0x61, 0x2e, 0x20, 0x43, 0x75, 0x6d, 0x20, 0x73, 0x6f, 0x63, 0x69,
                0x69, 0x73, 0x20, 0x6e, 0x61, 0x74, 0x6f, 0x71, 0x75, 0x65, 0x20, 0x70, 0x65, 0x6e, 0x61, 0x74, 0x69,
                0x62, 0x75, 0x73, 0x20, 0x65, 0x74, 0x20, 0x6d, 0x61, 0x67, 0x6e, 0x69, 0x73, 0x20, 0x64, 0x69, 0x73,
                0x20, 0x70, 0x61, 0x72, 0x74, 0x75, 0x72, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x6f, 0x6e, 0x74, 0x65,
                0x73, 0x2c, 0x20, 0x6e, 0x61, 0x73, 0x63, 0x65, 0x74, 0x75, 0x72, 0x20, 0x72, 0x69, 0x64, 0x69, 0x63,
                0x75, 0x6c, 0x75, 0x73, 0x20, 0x6d, 0x75, 0x73, 0x2e, 0x20, 0x44, 0x6f, 0x6e, 0x65, 0x63, 0x20, 0x71,
                0x75, 0x61, 0x6d, 0x20, 0x66, 0x65, 0x6c, 0x69, 0x73, 0x2c, 0x20, 0x75, 0x6c, 0x74, 0x72, 0x69, 0x63,
                0x69, 0x65, 0x73, 0x20, 0x6e, 0x65, 0x63, 0x2c, 0x20, 0x70, 0x65, 0x6c, 0x6c, 0x65, 0x6e, 0x74, 0x65,
                0x73, 0x71, 0x75, 0x65, 0x20, 0x65, 0x75, 0x2c, 0x20, 0x70, 0x72, 0x65, 0x74, 0x69, 0x75, 0x6d, 0x20,
                0x71, 0x75, 0x69, 0x73, 0x2c, 0x20, 0x73, 0x65, 0x6d, 0x2e, 0x20, 0x4e, 0x75, 0x6c, 0x6c, 0x61, 0x20,
                0x63, 0x6f, 0x6e, 0x73, 0x65, 0x71, 0x75, 0x61, 0x74, 0x20, 0x6d, 0x61, 0x73, 0x73, 0x61, 0x20, 0x71,
                0x75, 0x69, 0x73, 0x20, 0x65, 0x6e, 0x69, 0x6d, 0x2e, 0x20, 0x44, 0x6f, 0x6e, 0x65, 0x63, 0x20, 0x70,
                0x65, 0x64, 0x65, 0x20, 0x6a, 0x75, 0x73, 0x74, 0x6f, 0x2c, 0x20, 0x66, 0x72, 0x69, 0x6e, 0x67, 0x69,
                0x6c, 0x6c, 0x61, 0x20, 0x76, 0x65, 0x6c, 0x2c, 0x20, 0x61, 0x6c, 0x69, 0x71, 0x75, 0x65, 0x74, 0x20,
                0x6e, 0x65, 0x63, 0x2c, 0x20, 0x76, 0x75, 0x6c, 0x70, 0x75, 0x74, 0x61, 0x74, 0x65, 0x20, 0x65, 0x67,
                0x65, 0x74, 0x2c, 0x20, 0x61, 0x72, 0x63, 0x75, 0x2e, 0x20, 0x49, 0x6e, 0x20, 0x65, 0x6e, 0x69, 0x6d,
                0x20, 0x6a, 0x75, 0x73, 0x74, 0x6f, 0x2c, 0x20, 0x72, 0x68, 0x6f, 0x6e, 0x63, 0x75, 0x73, 0x20, 0x75,
                0x74, 0x2c, 0x20, 0x69, 0x6d, 0x70, 0x65, 0x72, 0x64, 0x69, 0x65, 0x74, 0x20, 0x61, 0x2c, 0x20, 0x76,
                0x65, 0x6e, 0x65, 0x6e, 0x61, 0x74, 0x69, 0x73, 0x20, 0x76, 0x69, 0x74, 0x61, 0x65, 0x2c, 0x20, 0x6a,
                0x75, 0x73, 0x74, 0x6f, 0x2e, 0x20, 0x4e, 0x75, 0x6c, 0x6c, 0x61, 0x6d, 0x20, 0x64, 0x69, 0x63, 0x74,
                0x75, 0x6d, 0x20, 0x66, 0x65, 0x6c, 0x69, 0x73, 0x20, 0x65, 0x75, 0x20, 0x70, 0x65, 0x64, 0x65, 0x20,
                0x6d, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x20, 0x70, 0x72, 0x65, 0x74, 0x69, 0x75, 0x6d, 0x2e, 0x20, 0x49,
                0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x74, 0x69, 0x6e, 0x63, 0x69, 0x64, 0x75, 0x6e, 0x74, 0x2e,
                0x20, 0x43, 0x72, 0x61, 0x73, 0x20, 0x64, 0x61, 0x70, 0x69, 0x62, 0x75, 0x73, 0x2e, 0x20, 0x56, 0x69,
                0x76, 0x61, 0x6d, 0x75, 0x73, 0x20, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x75, 0x6d, 0x20, 0x73,
                0x65, 0x6d, 0x70, 0x65, 0x72, 0x20, 0x6e, 0x69, 0x73, 0x69, 0x2e, 0x20, 0x41, 0x65, 0x6e, 0x65, 0x61,
                0x6e, 0x20, 0x76, 0x75, 0x6c, 0x70, 0x75, 0x74, 0x61, 0x74, 0x65, 0x20, 0x65, 0x6c, 0x65, 0x69, 0x66,
                0x65, 0x6e, 0x64, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x75, 0x73, 0x2e });
        }

        void CheckArray(long[][] expected, byte[] vpack)
        {
            CheckLength(expected.Length, vpack);
            VPackSlice slice = new VPackSlice(vpack);
            for (int i = 0; i < expected.Length; i++)
            {
                long[] childArray = expected[i];
                VPackSlice at = slice[i];

                Assert.True(at.IsType(SliceType.Array));

                Assert.Equal(at.Length, childArray.Length);
                for (int j = 0; j < childArray.Length; j++)
                {
                    VPackSlice atat = at[j];

                    Assert.True(atat.IsInteger());

                    Assert.Equal(atat.ToInt64(), childArray[j]);
                }
            }
        }

        void CheckArray(long[] expected, byte[] vpack)
        {
            CheckLength(expected.Length, vpack);
            VPackSlice slice = new VPackSlice(vpack);
            for (int i = 0; i < expected.Length; i++)
            {
                VPackSlice at = slice[i];

                Assert.True(at.IsInteger());

                Assert.Equal(at.ToInt64(), expected[i]);
            }
        }

        [Fact]
        public void ArrayIterator()
        {
            List<string> expected = new List<string> { "a", "b", "c", "d", "e", "f" };
            VPackSlice slice = new VPackSlice(new byte[] { 0x13, 0x0f, 0x41, 0x61, 0x41, 0x62, 0x41, 0x63, 0x41, 0x64,
                0x41, 0x65, 0x41, 0x66, 0x06 });

            var sliceItems = slice.ArrayEnumerable().ToList();
            for (int i = 0; i < sliceItems.Count; i++)
            {
                var next = sliceItems[i];
                Assert.True(next.IsType(SliceType.String));
                Assert.Equal(next.ToStringValue(), expected[i]);
            }
        }

        [Fact]
        public void ObjectIterator()
        {
            // {"a":"test","b":"test","c":"test"}
            string[] fields = new string[] { "a", "b", "c" };
            VPackSlice slice = new VPackSlice(new byte[] { 0x0b, 0x1b, 0x03, 0x41, 0x61, 0x44, 0x74, 0x65, 0x73, 0x74,
                0x41, 0x62, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x63, 0x44, 0x74, 0x65, 0x73, 0x74, 0x03, 0x0a, 0x11 });

            var sliceItems = slice.ObjectEnumerable().ToList();
            for (int i = 0; i < sliceItems.Count; i++)
            {
                var next = sliceItems[i];
                Assert.Equal(next.Key, fields[i]);
                Assert.Equal(next.Value.ToStringValue(), "test");
            }
        }

        [Fact]
        public void NonArrayIterator()
        {
            VPackSlice vpack = new VPackSlice(new byte[] { 0x1a });
            Assert.Throws<VPackValueTypeException>(() => vpack.ArrayEnumerable());
        }

        [Fact]
        public void NonObjectIterator()
        {
            VPackSlice vpack = new VPackSlice(new byte[] { 0x1a });
            Assert.Throws<VPackValueTypeException>(() => vpack.ObjectEnumerable());
        }

        [Fact]
        public void ObjectEmpty()
        {
            CheckLength(0, new byte[] { 0x0a });
        }

        [Fact]
        public void ObjectLength()
        {
            // {"a": 12, "b": true, "c": "xyz"}
            int expected = 3;

            CheckLength(expected, new byte[] { 0x0b, 0x13, 0x03, 0x41, 0x62, 0x1a, 0x41, 0x61, 0x28, 0x0c, 0x41, 0x63, 0x43,
                0x78, 0x79, 0x7a, 0x06, 0x03, 0x0a });

            CheckLength(expected,

                new byte[] { 0x0d, 0x22, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x41, 0x62, 0x03, 0x41, 0x61, 0x28, 0x0c,
                    0x41, 0x63, 0x43, 0x78, 0x79, 0x7a, 0x0c, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x10, 0x00,
                    0x00, 0x00 });

            CheckLength(expected, new byte[] { 0x0f, 0x13, 0x03, 0x41, 0x62, 0x03, 0x41, 0x61, 0x28, 0x0c, 0x41, 0x63, 0x43,
                0x78, 0x79, 0x7a, 0x03, 0x06, 0x0a });
        }

        [Fact]
        public void ObjectCompactLength()
        {
            // {"a":1, "b":16}
            CheckLength(2, new byte[] { 0x14, 0x0a, 0x41, 0x61, 0x31, 0x41, 0x62, 0x28, 0x10, 0x02 });
        }

        void CheckLength(int expected, byte[] vpack)
        {
            VPackSlice slice = new VPackSlice(vpack);

            Assert.Equal(slice.Length, expected);

            Assert.Equal(slice.GetByteSize(), vpack.Length);
        }

        [Fact]
        public void ObjectEmptyGet()
        {
            VPackSlice slice = new VPackSlice(new byte[] { 0x0a });
            VPackSlice slice2 = slice["abc"];

            Assert.True(slice2.IsType(SliceType.None));
        }

        [Fact]
        public void ObjectSingleEntryString()
        {
            // {"a":"b"}
            VPackSlice slice = new VPackSlice(new byte[] { 0x0b, 0x07, 0x01, 0x41, 0x61, 0x41, 0x62 });
            VPackSlice sliceNone = slice["abc"];

            Assert.True(sliceNone.IsType(SliceType.None));
            VPackSlice sliceA = slice["a"];

            Assert.True(sliceA.IsType(SliceType.String));
        }

        [Fact]
        public void ObjectSorted4Entries()
        {
            // {"a":"b","c":"d","e":"f","g":"h"}
            VPackSlice slice = new VPackSlice(new byte[] { 0x0b, 0x17, 0x04, 0x41, 0x61, 0x41, 0x62, 0x41, 0x63, 0x41,
                0x64, 0x41, 0x65, 0x41, 0x66, 0x41, 0x67, 0x41, 0x68, 0x03, 0x07, 0x0b, 0x0f });

            CheckString("b", slice["a"]);

            CheckString("d", slice["c"]);

            CheckString("f", slice["e"]);

            CheckString("h", slice["g"]);
        }

        [Fact]
        public void ObjectSortedUnder4Entries()
        {
            // {"a":"b","c":"d","e":"f"}
            VPackSlice slice = new VPackSlice(new byte[] { 0x0b, 0x12, 0x03, 0x41, 0x61, 0x41, 0x62, 0x41, 0x63, 0x41,
                0x64, 0x41, 0x65, 0x41, 0x66, 0x03, 0x07, 0x0b });

            CheckString("b", slice["a"]);

            CheckString("d", slice["c"]);

            CheckString("f", slice["e"]);
        }

        [Fact]
        public void ObjectCompact()
        {
            // {"a":"b","c":"d","e":"f"}
            VPackSlice slice = new VPackSlice(new byte[] { 0x14, 0x0f, 0x41, 0x61, 0x41, 0x62, 0x41, 0x63, 0x41, 0x64,
                0x41, 0x65, 0x41, 0x66, 0x03 });

            CheckString("b", slice["a"]);

            CheckString("d", slice["c"]);

            CheckString("f", slice["e"]);
        }

        void CheckString(string expected, VPackSlice slice)
        {
            Assert.True(slice.IsType(SliceType.String));
            Assert.Equal(slice.ToStringValue(), expected);
        }

        [Fact]
        public void ObjectKeyValueAtIndex()
        {
            // {"a":"b","c":"d","e":"f"}
            string[] keys = { "a", "c", "e" };
            string[] values = { "b", "d", "f" };
            VPackSlice slice = new VPackSlice(new byte[] { 0x14, 0x0f, 0x41, 0x61, 0x41, 0x62, 0x41, 0x63, 0x41, 0x64,
                0x41, 0x65, 0x41, 0x66, 0x03 });
            for (int i = 0; i < 3; i++)
            {
                CheckString(keys[i], slice.KeyAt(i));

                CheckString(values[i], slice.ValueAt(i));
            }
        }

        [Fact]
        public void Object1ByteOffset()
        {
            /*
             * {"0":{"0":"test","1":"test","2":"test","3":"test","4":"test"},
             * "1":{"0":"test","1":"test","2":"test","3":"test","4":"test"},
             * "2":{"0":"test","1":"test","2":"test","3":"test","4":"test"},
             * "3":{"0":"test","1":"test","2":"test","3":"test","4":"test"},
             * "4":{"0":"test","1":"test","2":"test","3":"test","4":"test"}}
             */
            VPackSlice slice = new VPackSlice(new byte[] { 0x0b, 0xe9, 0x05, 0x41, 0x30, 0x0b, 0x2b, 0x05,
                0x41, 0x30, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x31, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x32, 0x44,
                0x74, 0x65, 0x73, 0x74, 0x41, 0x33, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x34, 0x44, 0x74, 0x65, 0x73,
                0x74, 0x03, 0x0a, 0x11, 0x18, 0x1f, 0x41, 0x31, 0x0b, 0x2b, 0x05, 0x41, 0x30, 0x44, 0x74, 0x65, 0x73,
                0x74, 0x41, 0x31, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x32, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x33,
                0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x34, 0x44, 0x74, 0x65, 0x73, 0x74, 0x03, 0x0a, 0x11, 0x18, 0x1f,
                0x41, 0x32, 0x0b, 0x2b, 0x05, 0x41, 0x30, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x31, 0x44, 0x74, 0x65,
                0x73, 0x74, 0x41, 0x32, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x33, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41,
                0x34, 0x44, 0x74, 0x65, 0x73, 0x74, 0x03, 0x0a, 0x11, 0x18, 0x1f, 0x41, 0x33, 0x0b, 0x2b, 0x05, 0x41,
                0x30, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x31, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x32, 0x44, 0x74,
                0x65, 0x73, 0x74, 0x41, 0x33, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x34, 0x44, 0x74, 0x65, 0x73, 0x74,
                0x03, 0x0a, 0x11, 0x18, 0x1f, 0x41, 0x34, 0x0b, 0x2b, 0x05, 0x41, 0x30, 0x44, 0x74, 0x65, 0x73, 0x74,
                0x41, 0x31, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x32, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x33, 0x44,
                0x74, 0x65, 0x73, 0x74, 0x41, 0x34, 0x44, 0x74, 0x65, 0x73, 0x74, 0x03, 0x0a, 0x11, 0x18, 0x1f, 0x03,
                0x30, 0x5d, 0x8a, 0xb7 });
            int size = 5;

            Assert.True(slice.IsType(SliceType.Object));

            Assert.Equal(slice.Length, size);
            for (int i = 0; i < size; i++)
            {
                VPackSlice attr = slice[i.ToString()];

                Assert.True(attr.IsType(SliceType.Object));

                Assert.Equal(attr.Length, size);
                for (int j = 0; j < size; j++)
                {
                    VPackSlice childAttr = attr[j.ToString()];

                    Assert.True(childAttr.IsType(SliceType.String));
                }
            }
        }

        [Fact]
        public void Object2ByteOffset()
        {
            /*
             * {"0":{"0":"test","1":"test","2":"test","3":"test","4":"test","5":
             * "test","6":"test","7":"test","8":"test","9":"test"},
             * "1":{"0":"test","1":"test","2":"test","3":"test","4":"test","5":
             * "test","6":"test","7":"test","8":"test","9":"test"},
             * "2":{"0":"test","1":"test","2":"test","3":"test","4":"test","5":
             * "test","6":"test","7":"test","8":"test","9":"test"},
             * "3":{"0":"test","1":"test","2":"test","3":"test","4":"test","5":
             * "test","6":"test","7":"test","8":"test","9":"test"},
             * "4":{"0":"test","1":"test","2":"test","3":"test","4":"test","5":
             * "test","6":"test","7":"test","8":"test","9":"test"},
             * "5":{"0":"test","1":"test","2":"test","3":"test","4":"test","5":
             * "test","6":"test","7":"test","8":"test","9":"test"},
             * "6":{"0":"test","1":"test","2":"test","3":"test","4":"test","5":
             * "test","6":"test","7":"test","8":"test","9":"test"},
             * "7":{"0":"test","1":"test","2":"test","3":"test","4":"test","5":
             * "test","6":"test","7":"test","8":"test","9":"test"},
             * "8":{"0":"test","1":"test","2":"test","3":"test","4":"test","5":
             * "test","6":"test","7":"test","8":"test","9":"test"},
             * "9":{"0":"test","1":"test","2":"test","3":"test","4":"test","5":
             * "test","6":"test","7":"test","8":"test","9":"test"}}
             */
            VPackSlice slice = new VPackSlice(new byte[] { 0x0c, 0x6f, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41,
                0x30, 0x0b, 0x53, 0x0a, 0x41, 0x30, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x31, 0x44, 0x74, 0x65, 0x73,
                0x74, 0x41, 0x32, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x33, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x34,
                0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x35, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x36, 0x44, 0x74, 0x65,
                0x73, 0x74, 0x41, 0x37, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x38, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41,
                0x39, 0x44, 0x74, 0x65, 0x73, 0x74, 0x03, 0x0a, 0x11, 0x18, 0x1f, 0x26, 0x2d, 0x34, 0x3b, 0x42, 0x41,
                0x31, 0x0b, 0x53, 0x0a, 0x41, 0x30, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x31, 0x44, 0x74, 0x65, 0x73,
                0x74, 0x41, 0x32, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x33, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x34,
                0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x35, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x36, 0x44, 0x74, 0x65,
                0x73, 0x74, 0x41, 0x37, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x38, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41,
                0x39, 0x44, 0x74, 0x65, 0x73, 0x74, 0x03, 0x0a, 0x11, 0x18, 0x1f, 0x26, 0x2d, 0x34, 0x3b, 0x42, 0x41,
                0x32, 0x0b, 0x53, 0x0a, 0x41, 0x30, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x31, 0x44, 0x74, 0x65, 0x73,
                0x74, 0x41, 0x32, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x33, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x34,
                0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x35, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x36, 0x44, 0x74, 0x65,
                0x73, 0x74, 0x41, 0x37, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x38, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41,
                0x39, 0x44, 0x74, 0x65, 0x73, 0x74, 0x03, 0x0a, 0x11, 0x18, 0x1f, 0x26, 0x2d, 0x34, 0x3b, 0x42, 0x41,
                0x33, 0x0b, 0x53, 0x0a, 0x41, 0x30, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x31, 0x44, 0x74, 0x65, 0x73,
                0x74, 0x41, 0x32, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x33, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x34,
                0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x35, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x36, 0x44, 0x74, 0x65,
                0x73, 0x74, 0x41, 0x37, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x38, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41,
                0x39, 0x44, 0x74, 0x65, 0x73, 0x74, 0x03, 0x0a, 0x11, 0x18, 0x1f, 0x26, 0x2d, 0x34, 0x3b, 0x42, 0x41,
                0x34, 0x0b, 0x53, 0x0a, 0x41, 0x30, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x31, 0x44, 0x74, 0x65, 0x73,
                0x74, 0x41, 0x32, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x33, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x34,
                0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x35, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x36, 0x44, 0x74, 0x65,
                0x73, 0x74, 0x41, 0x37, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x38, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41,
                0x39, 0x44, 0x74, 0x65, 0x73, 0x74, 0x03, 0x0a, 0x11, 0x18, 0x1f, 0x26, 0x2d, 0x34, 0x3b, 0x42, 0x41,
                0x35, 0x0b, 0x53, 0x0a, 0x41, 0x30, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x31, 0x44, 0x74, 0x65, 0x73,
                0x74, 0x41, 0x32, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x33, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x34,
                0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x35, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x36, 0x44, 0x74, 0x65,
                0x73, 0x74, 0x41, 0x37, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x38, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41,
                0x39, 0x44, 0x74, 0x65, 0x73, 0x74, 0x03, 0x0a, 0x11, 0x18, 0x1f, 0x26, 0x2d, 0x34, 0x3b, 0x42, 0x41,
                0x36, 0x0b, 0x53, 0x0a, 0x41, 0x30, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x31, 0x44, 0x74, 0x65, 0x73,
                0x74, 0x41, 0x32, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x33, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x34,
                0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x35, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x36, 0x44, 0x74, 0x65,
                0x73, 0x74, 0x41, 0x37, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x38, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41,
                0x39, 0x44, 0x74, 0x65, 0x73, 0x74, 0x03, 0x0a, 0x11, 0x18, 0x1f, 0x26, 0x2d, 0x34, 0x3b, 0x42, 0x41,
                0x37, 0x0b, 0x53, 0x0a, 0x41, 0x30, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x31, 0x44, 0x74, 0x65, 0x73,
                0x74, 0x41, 0x32, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x33, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x34,
                0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x35, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x36, 0x44, 0x74, 0x65,
                0x73, 0x74, 0x41, 0x37, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x38, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41,
                0x39, 0x44, 0x74, 0x65, 0x73, 0x74, 0x03, 0x0a, 0x11, 0x18, 0x1f, 0x26, 0x2d, 0x34, 0x3b, 0x42, 0x41,
                0x38, 0x0b, 0x53, 0x0a, 0x41, 0x30, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x31, 0x44, 0x74, 0x65, 0x73,
                0x74, 0x41, 0x32, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x33, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x34,
                0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x35, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x36, 0x44, 0x74, 0x65,
                0x73, 0x74, 0x41, 0x37, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x38, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41,
                0x39, 0x44, 0x74, 0x65, 0x73, 0x74, 0x03, 0x0a, 0x11, 0x18, 0x1f, 0x26, 0x2d, 0x34, 0x3b, 0x42, 0x41,
                0x39, 0x0b, 0x53, 0x0a, 0x41, 0x30, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x31, 0x44, 0x74, 0x65, 0x73,
                0x74, 0x41, 0x32, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x33, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x34,
                0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x35, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x36, 0x44, 0x74, 0x65,
                0x73, 0x74, 0x41, 0x37, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41, 0x38, 0x44, 0x74, 0x65, 0x73, 0x74, 0x41,
                0x39, 0x44, 0x74, 0x65, 0x73, 0x74, 0x03, 0x0a, 0x11, 0x18, 0x1f, 0x26, 0x2d, 0x34, 0x3b, 0x42, 0x09,
                0x00, 0x5e, 0x00, 0xb3, 0x00, 0x08, 0x01, 0x5d, 0x01, 0xb2, 0x01, 0x07, 0x02, 0x5c, 0x02,
                0xb1, 0x02, 0x06, 0x03 });
            int size = 10;

            Assert.True(slice.IsType(SliceType.Object));

            Assert.Equal(slice.Length, size);
            for (int i = 0; i < size; i++)
            {
                VPackSlice attr = slice[i.ToString()];

                Assert.True(attr.IsType(SliceType.Object));

                Assert.Equal(attr.Length, size);
                for (int j = 0; j < size; j++)
                {
                    VPackSlice childAttr = attr[j.ToString()];

                    Assert.True(childAttr.IsType(SliceType.String));
                }
            }
        }

        [Fact]
        public void AttributeAdapter()
        {
            // {1:"a"}
            // {"_key":"a"}
            VPackSlice slice = new VPackSlice(new byte[] { 0x0b, 0x06, 0x01, 0x31, 0x41, 0x61 });

            Assert.True(slice.IsType(SliceType.Object));

            Assert.Equal(slice.Length, 1);
            VPackSlice key = slice["_key"];

            Assert.True(key.IsType(SliceType.String));

            Assert.Equal(key.ToStringValue(), "a");
        }

        [Fact]
        public void AttributeAdapterDefaults()
        {
            // {1:"a",2:"b",3:"c",4:"d",5:"e"}
            // {"_key":"a","_rev":"b","_id":"c","_from":"d","_to":"e"}
            VPackSlice slice = new VPackSlice(new byte[] { 0x14, 0x12, 0x31, 0x41, 0x61, 0x32, 0x41, 0x62, 0x33, 0x41,
                0x63, 0x34, 0x41, 0x64, 0x35, 0x41, 0x65, 0x05 });

            Assert.True(slice.IsType(SliceType.Object));

            Assert.Equal(slice.Length, 5);
            {
                VPackSlice key = slice["_key"];

                Assert.True(key.IsType(SliceType.String));

                Assert.Equal(key.ToStringValue(), "a");
            }
            {
                VPackSlice rev = slice["_rev"];

                Assert.True(rev.IsType(SliceType.String));

                Assert.Equal(rev.ToStringValue(), "b");
            }
            {
                VPackSlice id = slice["_id"];

                Assert.True(id.IsType(SliceType.String));

                Assert.Equal(id.ToStringValue(), "c");
            }
            {
                VPackSlice from = slice["_from"];

                Assert.True(from.IsType(SliceType.String));

                Assert.Equal(from.ToStringValue(), "d");
            }
            {
                VPackSlice to = slice["_to"];

                Assert.True(to.IsType(SliceType.String));

                Assert.Equal(to.ToStringValue(), "e");
            }
        }

        [Fact]
        public void AttributeAdapterObjectWithIndexTable()
        {
            // {1:"a",2:"b",3:"c",4:"d",5:"e"}
            // {"_key":"a","_rev":"b","_id":"c","_from":"d","_to":"e"}
            VPackSlice slice = new VPackSlice(new byte[] { 0x0b, 0x21, 0x05, 0x31, 0x41, 0x61, 0x32, 0x42, 0x62, 0x62,
                0x33, 0x43, 0x63, 0x63, 0x63, 0x34, 0x44, 0x64, 0x64, 0x64, 0x64, 0x35, 0x45, 0x65, 0x65, 0x65, 0x65,
                0x65, 0x0f, 0x0a, 0x03, 0x06, 0x15 });

            Assert.True(slice.IsType(SliceType.Object));

            Assert.Equal(slice.Length, 5);
            {
                VPackSlice key = slice["_key"];

                Assert.True(key.IsType(SliceType.String));

                Assert.Equal(key.ToStringValue(), "a");
            }
            {
                VPackSlice rev = slice["_rev"];

                Assert.True(rev.IsType(SliceType.String));

                Assert.Equal(rev.ToStringValue(), "bb");
            }
            {
                VPackSlice id = slice["_id"];

                Assert.True(id.IsType(SliceType.String));

                Assert.Equal(id.ToStringValue(), "ccc");
            }
            {
                VPackSlice from = slice["_from"];

                Assert.True(from.IsType(SliceType.String));

                Assert.Equal(from.ToStringValue(), "dddd");
            }
            {
                VPackSlice to = slice["_to"];

                Assert.True(to.IsType(SliceType.String));

                Assert.Equal(to.ToStringValue(), "eeeee");
            }
        }

        [Fact]
        public void GetLengthFail()
        {
            VPackSlice slice = new VPackSlice(new byte[] { 0x00 });
            Assert.Throws<VPackValueTypeException>(() => slice.Length);
        }

        [Fact]
        public void GetNoObjectGetFail()
        {
            VPackSlice slice = new VPackSlice(new byte[] { 0x00 });
            Assert.Throws<VPackValueTypeException>(() => slice["a"]);
        }

        [Fact]
        public void getNoObjectKeyAtFail()
        {
            VPackSlice slice = new VPackSlice(new byte[] { 0x00 });
            Assert.Throws<VPackValueTypeException>(() => slice.KeyAt(0));
        }

        [Fact]
        public void getNoObjectValueAtFail()
        {
            VPackSlice slice = new VPackSlice(new byte[] { 0x00 });
            Assert.Throws<VPackValueTypeException>(() => slice.ValueAt(0));
        }

    }
}
